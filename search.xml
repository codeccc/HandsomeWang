<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F%E5%AE%9E%E7%8E%B0Android%20%E5%BD%A9%E8%89%B2%E6%B8%90%E5%8F%98%E7%8A%B6%E6%80%81%E6%A0%8F.html</url>
    <content type="text"><![CDATA[### 实现Android 彩色渐变状态栏 title: 实现Android 彩色渐变状态栏date: 2017-08-04 18:10:22tags: [android,状态栏]categories: androidtop: 101 ​ 一般应用的开发都是纯色状态栏或者透明状态栏,一般开发者也很少或者基本不接触渐变色状态栏这个东西,但如果项目需求需要做渐变色状态栏,这种需求该如何处理了.接下来我将以我的实现效果为例,讲解这种效果对应的解决办法。话不多说,先来看一眼效果图吧: 效果显示很不错的,接下来正式进入我们的教程。 1.首先在colors.xml中定义好使用的颜色12&lt;color name="theme_color_one"&gt;#f8b195&lt;/color&gt;&lt;color name="theme_color_two"&gt;#f291b0&lt;/color&gt; 2.在drawable文件加下创建statusbar_theme_shape.xml文件,并添加如下代码:12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;corners android:radius="2dp"/&gt; &lt;gradient android:angle="0" android:endColor="@color/theme_color_two" android:startColor="@color/theme_color_one"/&gt;&lt;/shape&gt; 3.在layout中创建activity_base.xml文件,添加如下代码:123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/root_view" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;View android:id="@+id/statusBarBg" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/btn_theme_shape"/&gt; &lt;FrameLayout android:id="@+id/content_view" android:layout_width="match_parent" android:layout_height="match_parent" android:fillViewport="true"&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 3.创建BaseActivity.class类,添加如下代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //得到布局id protected abstract int getLayoutId(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (!isCustomStatusBar()) &#123; initWindowParameter(); &#125; //设置视图 setContentView(R.layout.activity_base); initContentView(); &#125; /** *初始化内容视图 */ private void initContentView() &#123; //得到内容视图 mContentView = (ViewGroup) findViewById(R.id.content_view); //得到状态栏视图 mStatusView = findViewById(R.id.statusBarBg); if (mLayoutView == null) &#123; int layoutId = getLayoutId(); if (layoutId != 0) &#123; mBinding = DataBindingUtil.inflate(getLayoutInflater(), layoutId, mContentView, false); &#125; //得到继承自BaseActivity的Activity的根视图 mLayoutView = mBinding.getRoot(); &#125; //清除所有视图 mContentView.removeAllViews(); //将子类的根视图添加到内容视图中 mContentView.addView(mLayoutView); //设置状态栏样式 setStatusBarColor(); &#125; /** * 设置状态栏颜色 */ public void setStatusBarColor() &#123; //从Android4.4开始加入对状态栏样式的更改 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; //得到状态栏高度并设置状态栏参数 LinearLayout.LayoutParams lParams = new LinearLayout.LayoutParams(LinearLayout .LayoutParams.MATCH_PARENT, ScreenUtils.getStatusHeight(this)); mStatusView.setBackgroundResource(R.drawable.btn_theme_shape); mStatusView.setLayoutParams(lParams); &#125; &#125; /** * 设置状态栏等与Window相关的参数 */ protected void initWindowParameter() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;//5.0+ View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;// if (mIsLight) &#123; //如果StatusBar为亮色主题的话，则文字颜色为深色// option = option | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;// &#125; decorView.setSystemUiVisibility(option); //设置透明状态栏 getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;//4.4~5.0 WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); //设置透明状态栏 localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; //设置Activity与软键盘的交互方式 getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); &#125; 5.所有需要实现渐变状态栏的Activity继承自BaseActivity便可实现这种渐变色状态栏的效果]]></content>
  </entry>
  <entry>
    <title><![CDATA[Android基于X5内核 WebView项目套壳优化]]></title>
    <url>%2FAndroid%E5%9F%BA%E4%BA%8EX5%E5%86%85%E6%A0%B8%20WebView%E9%A1%B9%E7%9B%AE%E5%A5%97%E5%A3%B3%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[一、webview加载缓慢,如何提高加载使用效率? 设置渲染等级为高 1settings.setRenderPriority(WebSettings.RenderPriority.HIGH); 在java代码中动态创建webview 123WebView webView = new WebView(getApplicationContext(), null);webView.setLayoutParams(new ViewGroup.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));mBinding.mainView.addView(webView, 0); 二、Webview缓存使用策略webview的五种缓存策略模式:12345public static final int LOAD_DEFAULT = -1;//默认模式public static final int LOAD_NORMAL = 0;//普通模式public static final int LOAD_CACHE_ELSE_NETWORK = 1;//如果有缓存,优先加载缓存,否则从网络获取数据public static final int LOAD_NO_CACHE = 2;//不加载缓存,只从网络获取数据public static final int LOAD_CACHE_ONLY = 3;//只加载缓存 如果加载的是静态页面,网页数据样式固定,则推荐使用LOAD_CACHE_ELSE_NETWORK模式; 如果加载的数据是从服务器动态获取的,比如帖子论坛页面,个人信息页面,则推荐使用LOAD_NO_CACHE,以保证每次都能获取最新内容 如果加载的网页是app端内置于assets目录写死的网页,则可以使用LOAD_CACHE_ONLY模式; 三、关于webview页面输入法弹窗遮挡输入框的问题解决方案在Activity的OnCrate()方法中加入如下代码:1234this.getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN ); ,此段代码含义是输入法高度状态自适应,如果有输入法弹出,则重新调整页面布局使输入框处于输入法上面 四、webview网页加载速度提升在开始加载前设置settings.setBlockNetworkImage(true);先屏蔽掉加载网页,然后在设置webview的setWebViewClient()方法里new出新的WebViewClient()时,在重写的方法onPageFinished()中再设置mWebSettings.setBlockNetworkImage(false);取消图片加载屏蔽限制 五、WebView避免内存泄漏 不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext() 在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。123456789101112@Overrideprotected void onDestroy() &#123; if (mWebView != null) &#123; mWebView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); mWebView.clearHistory(); ((ViewGroup) mWebView.getParent()).removeView(mWebView); mWebView.destroy(); mWebView = null; &#125; super.onDestroy();&#125; 六、Webview的Cookie处理123456789101112131415161718192021222324252627282930/** * 设置浏览器的cookies */public void setCookies()&#123; if (NetCenter.cookies.length() &gt; 0) &#123; CookieSyncManager.createInstance(AppApplication.getInstance()); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.setAcceptThirdPartyCookies(webView, true);//解决cookie更新失败的问题 &#125; cookieManager.setCookie(NetCenter.PAGE_URL, NetCenter.cookies); CookieSyncManager.getInstance().sync(); &#125; &#125; /** * 清空浏览器的cookies */public void clearCookies()&#123; CookieSyncManager cookieSyncMngr = CookieSyncManager.createInstance(this); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeSessionCookie();// 移除 cookieManager.removeAllCookie();&#125; 七、WebChromeClient文件上传处理123456789101112131415161718192021222324252627282930webView.setWebChromeClient(new WebChromeClient()&#123; //扩展浏览器上传文件 //3.0++版本 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; openPicForWebClient(uploadMsg); &#125; //3.0--版本 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openPicForWebClient(uploadMsg); &#125; public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openPicForWebClient(uploadMsg); &#125; // For Android &gt; 5.0,移动端需要处理的核心 public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; uploadMsg, WebChromeClient.FileChooserParams fileChooserParams) &#123; openPicForWebClient(uploadMsg); return true; &#125;&#125;); ,上传核心代码12Uri uri=...;mUploadMessage.onReceiveValue(uri); ,在选择好图片或者文件后调用ValueCallback&lt;Uri&gt; uploadMsg的onReceiveValue传入文件的uri即可上传文件。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改android 4.4以上系统的状态栏和控制栏颜色]]></title>
    <url>%2F%E6%9B%B4%E6%94%B9android-4-4%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E6%A0%8F%E9%A2%9C%E8%89%B2.html</url>
    <content type="text"><![CDATA[心灵毒汤: 有时候不努力一把真的不知道什么叫绝望 这篇文章来介绍如何在java代码中更改系统状态栏和控制栏的颜色。 12345678910// 设置顶部状态栏颜色（此功能仅19版本以上可用）if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; Window window = getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); SystemBarTintManager tintManager = new SystemBarTintManager(this); // 激活状态栏设置 tintManager.setStatusBarTintEnabled(true); // 使用颜色资源 tintManager.setStatusBarTintResource(R.color.button_pressed);&#125; 上面代码的意思就是 首先将状态栏的设置为透明，不透明，下面你设置的颜色是没有效果的。 然后再激活状态栏的设置。 给状态栏设置颜色]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>状态栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>