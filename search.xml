<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mvplib框架讲解之mvp篇]]></title>
    <url>%2Fmvplib%E6%A1%86%E6%9E%B6%E8%AE%B2%E8%A7%A3%E4%B9%8Bmvp%E7%AF%87.html</url>
    <content type="text"><![CDATA[贵有恒何必三更起五更睡;最无益,只怕一日曝十日寒。 这篇文章讲述mvplib依赖库的相关功能及其用法。 一、mvplib的build.gradle 引用的依赖库及其他配置12345678910111213141516171819202122232425262728293031323334apply plugin: 'com.android.library'android &#123; compileSdkVersion 25 buildToolsVersion "25.0.3" defaultConfig &#123; minSdkVersion 14 targetSdkVersion 21 versionCode 1 versionName "1.0" testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125; dataBinding &#123;//启用DataBinding enabled = true &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.zhy:okhttputils:2.6.2'//OKHttpUtils库,引入OKhttp和Okio,习惯原生okhttp框架可以直接使用原生类 compile 'com.alibaba:fastjson:1.2.35'//json解析框架,阿里巴巴出品 compile 'com.xsf:zeusLog:1.0.0'//日志打印库 compile 'com.jph.takephoto:takephoto_library:4.0.3'//图片单选、多选、裁剪、压缩、运行时权限、Fileprovider适配于一体 compile 'com.zhy:autolayout:1.4.5'//屏幕适配&#125; 二、mvplib的项目结构介绍 包名说明 Package: 12345678adapter-------&gt;存放对Listview/Gridview的Adapter进行封装的类autolayout----&gt;屏幕适配相关类base----------&gt;存放BaseActivity,BaseFragment类,存放mvp基类base----mvp---&gt;mvp基类http----------&gt;网络请求相关封装及配置transform-----&gt;对Glide加载圆形圆角图片的拓展util----------&gt;Sharedpreferences封装,Toast封装,Activity管理封装等类widget--------&gt;加载提示框 三、 使用mvplib需要注意的地方1.关于Application的使用 如果需要用到`Application`则继承自mvplib的`App`,否则在`AndroidManifest.xml`的`application`中增加name属性,值为`com.beyondin.mvplib.App` 2.meta-data的配置​ 因为使用了autolayout 框架依赖mvplib需要在AndroidManifest.xml中加入如下代码: 123456&lt;meta-data android:name="design_width" android:value="1280"/&gt;&lt;meta-data android:name="design_height" android:value="720"/&gt; 关于屏幕适配autolayout的用法在这里查看: Android屏幕适配方案，直接填写设计图上的像素尺寸即可完成适配，最大限度解决适配问题。 四、正式使用mvplib进行开发正式开发之前我们先来看一张图来理解一下什么是mvp模式: ​ MVP模式的核心思想就是把Activity中的UI逻辑抽象成view接口，把Controller相关的业务逻辑抽象成presenter接口，Model还是原来的Model。 ​ MVP模式的作用分离了视图逻辑和业务逻辑，降低耦合度 Activity只处理生命周期相关的东西，代码更加简洁 视图逻辑和业务逻辑分别抽象到了View和Presenter的接口中，提高了代码的可阅读性 Presenter被抽象成接口，可以有多种具体的实现，方便进行单元测试 把业务逻辑抽象到Presenter中，避免后台线程引用Activity导致Activity的资源无法被系统回收从而引起内存泄漏和OOMActivity代码变的更加简洁 接下来我就以一个登录的例子来演示mvplib的用法: 首先我们来分析下登录界面的所具有的功能: ​ 1.有用户名和密码两个文本输入框,一个登录按钮,点击登录按钮获取到文本框的值,然后执行登录操作; ​ 2.将帐号密码保存到本地,本地持久化; ​ 3.下次打开登录界面自动填写用户名和密码; 1.首先先编写登录界面activity_login.xml的代码,我这里增加一个文本来展示登录的结果,实现的效果图如下: 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;LinearLayout android:id="@+id/activity_main" android:layout_width="match_parent" android:layout_height="match_parent" android:gravity="center" android:orientation="vertical" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="com.beyondin.mvp.LoginActivity"&gt; &lt;EditText android:id="@+id/edtUsername" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入用户名"/&gt; &lt;EditText android:id="@+id/edtPassword" android:layout_width="match_parent" android:layout_height="wrap_content" android:hint="请输入密码" android:inputType="textPassword"/&gt; &lt;Button android:id="@+id/btnLogin" android:layout_width="match_parent" android:layout_height="wrap_content" android:text="登录"/&gt; &lt;TextView android:id="@+id/txtResult" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_marginTop="50dp" android:text="登录结果:\n"/&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 2.确定登录要使用到的model登录需要用户名和密码,登录后会有登录的返回结果,其实登录不需要用到Model,这里为了做演示也为了方便对数据的同意处理我就编写了一个LoginModel,具体代码如下,很简单,就只包含用户名密码及返回的登陆结果: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class LoginModel extends BaseModel&#123; private String username;//用户名 private String password;//密码 private Result result; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public Result getResult() &#123; return result; &#125; public void setResult(Result result) &#123; this.result = result; &#125; /** * 登录结果 **/ public static class Result &#123; private String data; public String getData() &#123; return data; &#125; public void setData(String data) &#123; this.data = data; &#125; &#125;&#125; 3.开始编写LoginViewLoginView继承自BaseView,由于View是需要由Activity去实现具体的逻辑,所以这里将其定义成接口,BaseView里定义了五个常用的方法,如下: 123456789void loading();//加载中void stopLoading();//停止加载void shortToast(Object obj);//Toast提示void update(M m);//更新控件数据void updateList(List&lt;M&gt; list);//更新列表 登录界面我们上面提到过需要在启动的时候把数据从本地拿出来恢复到界面,所以在LoginView我们需要再单独去实现定义一个需要实现的方法: 123456/** * 从sp中拿到保存的登录帐号密码恢复到输入框中 * * @param model */ void resumeLogininfo(LoginModel model); ,至此LoginView编写完成,完整代码如下: 1234567891011public interface LoginView&lt;LoginModel extends BaseModel&gt; extends BaseView&lt;LoginModel&gt;&#123; /** * 从sp中拿到保存的登录帐号密码恢复到输入框中 * * @param model */ void resumeLogininfo(LoginModel model);&#125; 4.开始编写LoginPresenterPresenter负责我们的业务逻辑处理,比如与服务器进行数据交互,获取本地数据,一些与视图无关的其他操作逻辑等。 在上面需求中我们的LoginPresenter需要实现的业务逻辑有 1.从Sharedpreferences中读取保存的用户名密码:2.执行登录操作,将用户名及密码提交至服务器登;3.登录时将用户名密码保存到Sharedpreferences中;我们先来实现第一个逻辑,从Sharedpreferences中读取保存的用户名密码: ​ 首先定义我们的LoginPresenter,需要继承自BasePresenter&lt;LoginView&lt;LoginModel&gt;&gt;并传入泛型修饰,然后定义我们需要用到的全局变量: 12private LoginModel mLoginModel;private LoginModel.Result mResult; ​ 要获取sp中保存的用户名及密码,所以接着我们需要先初始化数据: 123456789public void initData()&#123; if (mLoginModel == null) &#123; mLoginModel = new LoginModel(); mLoginModel.setUsername(SPUtils.getWithAES(mContext, "username")); mLoginModel.setPassword(SPUtils.getWithAES(mContext, "password")); &#125;&#125; 上面已经把先从本地获取到用户名及密码保存在mLoginModel中,接下来我们先处理登录帐号密码恢复到输入框中的逻辑。由于给Edittext设置值属于View的范畴,所以我们这里只调用LoginView中定义的方法resumeLogininfo(LoginModel model)将数据交由view去实现: 1234567/** * 登录帐号密码恢复到输入框中*/public void resumeLoginInfo()&#123; mView.resumeLogininfo(mLoginModel);&#125; 接下来我们来实现presenter中的第二个逻辑: 执行登录操作,将用户名及密码提交至服务器。 登录这块我就做一个假的登录效果来演示登录了,代码如下: 12345678910111213141516171819202122232425262728private Handler mHandler = new Handler(Looper.getMainLooper());/** * 登录 * @param username 用户名 * @param password 密码 */public void login(String username, String password)&#123; mView.loading(); mLoginModel.setUsername(username); mLoginModel.setPassword(password); //.....执行登录操作,这里做个假登录 mResult = new LoginModel.Result(); mResult.setData("登录成功"); mLoginModel.setResult(mResult); //保存登录信息 saveLoginInfo(username, password); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mView.update(mLoginModel); mView.stopLoading(); &#125; &#125;, 3000);&#125; 登陆前需要弹出加载框,调用mView.loading();,登录成功后保存用户名密码,所以调用saveLoginInfo()方法,登录完成需要刷新界面,为了使加载框不一闪而过,所以这里我使用Handler来延迟刷新界面达到假的登录效果。 最后来实现我们presenter中第三个业务逻辑:登录时将用户名密码保存到Sharedpreferences中。 代码简单,我就不做过多说明,SPUtils是封装好的Sharedpreferences工具类,方法代码如下: 12345public void saveLoginInfo(String username, String password)&#123; SPUtils.putWithAES(mContext, "username", username); SPUtils.putWithAES(mContext, "password", password);&#125; 最后我们再重写onDestory方法来释放我们的数据: 123456789/** * 销毁方法 */@Overridepublic void onDestory()&#123; super.onDestory(); mLoginModel = null;&#125; 注意: onDestory 方法可选择性重写,如果自己处理业务逻辑时持有了Activity的东西或者其余一些需要释放的东西可以在这里进行销毁或者释放。 至此,我们的Presenter中需要的逻辑处理完毕。LoginPresenter的完整代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778public class LoginPresenter extends BasePresenter&lt;LoginView&lt;LoginModel&gt;&gt;&#123; private LoginModel mLoginModel; private LoginModel.Result mResult; public void initData() &#123; if (mLoginModel == null) &#123; mLoginModel = new LoginModel(); mLoginModel.setUsername(SPUtils.getWithAES(mContext, "username")); mLoginModel.setPassword(SPUtils.getWithAES(mContext, "password")); &#125; &#125; public LoginModel getLoginInfo() &#123; return mLoginModel; &#125; /** * 登录帐号密码恢复到输入框中 */ public void resumeLoginInfo() &#123; mView.resumeLogininfo(mLoginModel); &#125; private Handler mHandler = new Handler(Looper.getMainLooper()); /** * 登录 * @param username 用户名 * @param password 密码 */ public void login(String username, String password) &#123; mView.loading(); mLoginModel.setUsername(username); mLoginModel.setPassword(password); //.....执行登录操作,这里做个假登录 mResult = new LoginModel.Result(); mResult.setData("登录成功"); mLoginModel.setResult(mResult); //保存登录信息 saveLoginInfo(username, password); mHandler.postDelayed(new Runnable() &#123; @Override public void run() &#123; mView.update(mLoginModel); mView.stopLoading(); &#125; &#125;, 3000); &#125; public void saveLoginInfo(String username, String password) &#123; SPUtils.putWithAES(mContext, "username", username); SPUtils.putWithAES(mContext, "password", password); &#125; /** * 销毁方法 */ @Override public void onDestory() &#123; super.onDestory(); mLoginModel = null; &#125;&#125; 5.编写Activity代码Activity持有Presenter对象,并实现定义的View的接口,这我们先继承自BaseActivity&lt;LoginView&lt;LoginModel&gt;, LoginPresenter, ActivityLoginBinding&gt; 重写如下方法: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Overrideprotected Class&lt;LoginPresenter&gt; getPresenterClass()&#123; return LoginPresenter.class;&#125;@Overrideprotected void initView()&#123; mPresenter.resumeLoginInfo();//恢复登录信息 mBinding.btnLogin.setOnClickListener(this);&#125;@Overrideprotected void initData()&#123; mPresenter.initData();&#125;@Overrideprotected void create(Bundle savedInstanceState)&#123; initData();//初始化数据 initView();//初始化控件&#125;@Overrideprotected void resume()&#123;&#125;@Overrideprotected void pause()&#123;&#125;@Overrideprotected void destory()&#123; mPresenter.onDestory();//释放Presenter持有的Activity,防止内存泄漏&#125;@Overrideprotected int getLayoutId()&#123; return R.layout.activity_login;&#125;@Overridepublic void onClick(View v)&#123; switch (v.getId()) &#123; case R.id.btnLogin: mPresenter.login( mBinding.edtUsername.getText().toString().trim() , mBinding.edtPassword.getText().toString().trim() ); break; &#125;&#125; mPresenter在BaseActivity中初始化,子类Activity可以直接用,不过需要注意的是 12345@Overrideprotected Class&lt;LoginPresenter&gt; getPresenterClass()&#123; return LoginPresenter.class;&#125; 这个方法需要返回与之匹配的Presenter。 然后实现LoginView接口,重写如下方法: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@Overridepublic void loading()&#123; if (mLoadingDialog == null) &#123; //需要处理加载布局中的控件的相关处理逻辑可以选择设置LoadingPrepareListener监听 mLoadingDialog = new LoadingDialog(LoginActivity.this, R.layout.layout_loading, new LoadingPrepareListener &#123; @Override public void load(View view) &#123; view.findViewById(R.id.btnStop).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mLoadingDialog.dismissDialog(0); &#125; &#125;); &#125; &#125;); //不需要处理加载布局中的控件的相关处理逻辑传null mLoadingDialog = new LoadingDialog(this, R.layout.layout_loading, null); &#125; mLoadingDialog.showDialog();&#125;@Overridepublic void stopLoading()&#123; //设置延迟多少毫秒后关闭dialog mLoadingDialog.dismissDialog(0);&#125;/** * 恢复帐号密码到输入框 * @param model 包含帐号密码的实体类 */@Overridepublic void resumeLogininfo(LoginModel model)&#123; mBinding.edtUsername.setText(model.getUsername()); mBinding.edtPassword.setText(model.getPassword());&#125;@Overridepublic void update(LoginModel model)&#123; mBinding.txtResult.setText(model.getResult().getData());&#125;@Overridepublic void updateList(List&lt;LoginModel&gt; list)&#123;&#125; layout_loading.xml代码如下: 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="wrap_content" android:layout_height="wrap_content" android:background="@drawable/shape_bg_toast" android:gravity="center" android:orientation="vertical" android:padding="50dp"&gt; &lt;ProgressBar android:layout_width="wrap_content" android:layout_height="wrap_content" android:indeterminateTint="#ff4439"/&gt; &lt;Button android:id="@+id/btnStop" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="20dp" android:text="停止加载"/&gt;&lt;/LinearLayout&gt; 可以看到,Activity代码很简洁,都是些与View相关的东西,需要注意的是继承BaseActivity的泛型修饰,相关类前面已经便写好了,泛型修饰时可以直接写,需要注意Presenter的调用时机,根据自身需要适时调用presenter方法即可,需要注意一点的是 Presenter中的方法一般都要用public来修饰。 到这里mvplib的用法演示完毕,使用者可以来写个注册来体验使用这个框架。 五、 结尾 相关知识用法说明Android屏幕适配方案，直接填写设计图上的像素尺寸即可完成适配，最大限度解决适配问题。 OKHtputils的使用 完全掌握Android Data Binding Android 使用FastJson解析json数据的手把手分析 一款用于在Android设备上获取照片（拍照或从相册、文件中选择）、裁剪图片、压缩图片的开源工具库 支持移动端和控制台的日志工具]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>mvp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现Android 彩色渐变状态栏]]></title>
    <url>%2F%E5%AE%9E%E7%8E%B0Android%20%E5%BD%A9%E8%89%B2%E6%B8%90%E5%8F%98%E7%8A%B6%E6%80%81%E6%A0%8F.html</url>
    <content type="text"><![CDATA[​ 一般应用的开发都是纯色状态栏或者透明状态栏,一般开发者也很少或者基本不接触渐变色状态栏这个东西,但如果项目需求需要做渐变色状态栏,这种需求该如何处理了.接下来我将以我的实现效果为例,讲解这种效果对应的解决办法。话不多说,先来看一眼效果图吧: 效果显示很不错的,接下来正式进入我们的教程。 1.首先在colors.xml中定义好使用的颜色12&lt;color name="theme_color_one"&gt;#f8b195&lt;/color&gt;&lt;color name="theme_color_two"&gt;#f291b0&lt;/color&gt; 2.在drawable文件加下创建statusbar_theme_shape.xml文件,并添加如下代码:12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;shape xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;corners android:radius="2dp"/&gt; &lt;gradient android:angle="0" android:endColor="@color/theme_color_two" android:startColor="@color/theme_color_one"/&gt;&lt;/shape&gt; 3.在layout中创建activity_base.xml文件,添加如下代码:123456789101112131415161718&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:id="@+id/root_view" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical"&gt; &lt;View android:id="@+id/statusBarBg" android:layout_width="match_parent" android:layout_height="wrap_content" android:background="@drawable/btn_theme_shape"/&gt; &lt;FrameLayout android:id="@+id/content_view" android:layout_width="match_parent" android:layout_height="match_parent" android:fillViewport="true"&gt; &lt;/FrameLayout&gt;&lt;/LinearLayout&gt; 3.创建BaseActivity.class类,添加如下代码:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374 //得到布局id protected abstract int getLayoutId(); @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); if (!isCustomStatusBar()) &#123; initWindowParameter(); &#125; //设置视图 setContentView(R.layout.activity_base); initContentView(); &#125; /** *初始化内容视图 */ private void initContentView() &#123; //得到内容视图 mContentView = (ViewGroup) findViewById(R.id.content_view); //得到状态栏视图 mStatusView = findViewById(R.id.statusBarBg); if (mLayoutView == null) &#123; int layoutId = getLayoutId(); if (layoutId != 0) &#123; mBinding = DataBindingUtil.inflate(getLayoutInflater(), layoutId, mContentView, false); &#125; //得到继承自BaseActivity的Activity的根视图 mLayoutView = mBinding.getRoot(); &#125; //清除所有视图 mContentView.removeAllViews(); //将子类的根视图添加到内容视图中 mContentView.addView(mLayoutView); //设置状态栏样式 setStatusBarColor(); &#125; /** * 设置状态栏颜色 */ public void setStatusBarColor() &#123; //从Android4.4开始加入对状态栏样式的更改 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; //得到状态栏高度并设置状态栏参数 LinearLayout.LayoutParams lParams = new LinearLayout.LayoutParams(LinearLayout .LayoutParams.MATCH_PARENT, ScreenUtils.getStatusHeight(this)); mStatusView.setBackgroundResource(R.drawable.btn_theme_shape); mStatusView.setLayoutParams(lParams); &#125; &#125; /** * 设置状态栏等与Window相关的参数 */ protected void initWindowParameter() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;//5.0+ View decorView = getWindow().getDecorView(); int option = View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN | View.SYSTEM_UI_FLAG_LAYOUT_STABLE;// if (mIsLight) &#123; //如果StatusBar为亮色主题的话，则文字颜色为深色// option = option | View.SYSTEM_UI_FLAG_LIGHT_STATUS_BAR;// &#125; decorView.setSystemUiVisibility(option); //设置透明状态栏 getWindow().setStatusBarColor(Color.TRANSPARENT); &#125; else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;//4.4~5.0 WindowManager.LayoutParams localLayoutParams = getWindow().getAttributes(); //设置透明状态栏 localLayoutParams.flags = (WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS | localLayoutParams.flags); &#125; //设置Activity与软键盘的交互方式 getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN); &#125; 5.所有需要实现渐变状态栏的Activity继承自BaseActivity便可实现这种渐变色状态栏的效果]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>状态栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android基于X5内核 WebView项目套壳优化]]></title>
    <url>%2FAndroid%E5%9F%BA%E4%BA%8EX5%E5%86%85%E6%A0%B8%20WebView%E9%A1%B9%E7%9B%AE%E5%A5%97%E5%A3%B3%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[一、webview加载缓慢,如何提高加载使用效率? 设置渲染等级为高 1settings.setRenderPriority(WebSettings.RenderPriority.HIGH); 在java代码中动态创建webview 123WebView webView = new WebView(getApplicationContext(), null);webView.setLayoutParams(new ViewGroup.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));mBinding.mainView.addView(webView, 0); 二、Webview缓存使用策略webview的五种缓存策略模式:12345public static final int LOAD_DEFAULT = -1;//默认模式public static final int LOAD_NORMAL = 0;//普通模式public static final int LOAD_CACHE_ELSE_NETWORK = 1;//如果有缓存,优先加载缓存,否则从网络获取数据public static final int LOAD_NO_CACHE = 2;//不加载缓存,只从网络获取数据public static final int LOAD_CACHE_ONLY = 3;//只加载缓存 如果加载的是静态页面,网页数据样式固定,则推荐使用LOAD_CACHE_ELSE_NETWORK模式; 如果加载的数据是从服务器动态获取的,比如帖子论坛页面,个人信息页面,则推荐使用LOAD_NO_CACHE,以保证每次都能获取最新内容 如果加载的网页是app端内置于assets目录写死的网页,则可以使用LOAD_CACHE_ONLY模式; 三、关于webview页面输入法弹窗遮挡输入框的问题解决方案在Activity的OnCrate()方法中加入如下代码:1234this.getWindow().setSoftInputMode( WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE | WindowManager.LayoutParams.SOFT_INPUT_STATE_HIDDEN ); ,此段代码含义是输入法高度状态自适应,如果有输入法弹出,则重新调整页面布局使输入框处于输入法上面 四、webview网页加载速度提升在开始加载前设置settings.setBlockNetworkImage(true);先屏蔽掉加载网页,然后在设置webview的setWebViewClient()方法里new出新的WebViewClient()时,在重写的方法onPageFinished()中再设置mWebSettings.setBlockNetworkImage(false);取消图片加载屏蔽限制 五、WebView避免内存泄漏 不在xml中定义 Webview ，而是在需要的时候在Activity中创建，并且Context使用 getApplicationgContext() 在 Activity 销毁（ WebView ）的时候，先让 WebView 加载null内容，然后移除 WebView，再销毁 WebView，最后置空。123456789101112@Overrideprotected void onDestroy() &#123; if (mWebView != null) &#123; mWebView.loadDataWithBaseURL(null, "", "text/html", "utf-8", null); mWebView.clearHistory(); ((ViewGroup) mWebView.getParent()).removeView(mWebView); mWebView.destroy(); mWebView = null; &#125; super.onDestroy();&#125; 六、Webview的Cookie处理123456789101112131415161718192021222324252627282930/** * 设置浏览器的cookies */public void setCookies()&#123; if (NetCenter.cookies.length() &gt; 0) &#123; CookieSyncManager.createInstance(AppApplication.getInstance()); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.setAcceptCookie(true); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; cookieManager.setAcceptThirdPartyCookies(webView, true);//解决cookie更新失败的问题 &#125; cookieManager.setCookie(NetCenter.PAGE_URL, NetCenter.cookies); CookieSyncManager.getInstance().sync(); &#125; &#125; /** * 清空浏览器的cookies */public void clearCookies()&#123; CookieSyncManager cookieSyncMngr = CookieSyncManager.createInstance(this); CookieManager cookieManager = CookieManager.getInstance(); cookieManager.removeSessionCookie();// 移除 cookieManager.removeAllCookie();&#125; 七、WebChromeClient文件上传处理123456789101112131415161718192021222324252627282930webView.setWebChromeClient(new WebChromeClient()&#123; //扩展浏览器上传文件 //3.0++版本 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType) &#123; openPicForWebClient(uploadMsg); &#125; //3.0--版本 public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg) &#123; openPicForWebClient(uploadMsg); &#125; public void openFileChooser(ValueCallback&lt;Uri&gt; uploadMsg, String acceptType, String capture) &#123; openPicForWebClient(uploadMsg); &#125; // For Android &gt; 5.0,移动端需要处理的核心 public boolean onShowFileChooser(WebView webView, ValueCallback&lt;Uri[]&gt; uploadMsg, WebChromeClient.FileChooserParams fileChooserParams) &#123; openPicForWebClient(uploadMsg); return true; &#125;&#125;); ,上传核心代码12Uri uri=...;mUploadMessage.onReceiveValue(uri); ,在选择好图片或者文件后调用ValueCallback&lt;Uri&gt; uploadMsg的onReceiveValue传入文件的uri即可上传文件。]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>WebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更改android 4.4以上系统的状态栏和控制栏颜色]]></title>
    <url>%2F%E6%9B%B4%E6%94%B9android-4-4%E4%BB%A5%E4%B8%8A%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%8A%B6%E6%80%81%E6%A0%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E6%A0%8F%E9%A2%9C%E8%89%B2.html</url>
    <content type="text"><![CDATA[心灵毒汤: 有时候不努力一把真的不知道什么叫绝望 这篇文章来介绍如何在java代码中更改系统状态栏和控制栏的颜色。 12345678910// 设置顶部状态栏颜色（此功能仅19版本以上可用）if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; Window window = getWindow(); window.addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); SystemBarTintManager tintManager = new SystemBarTintManager(this); // 激活状态栏设置 tintManager.setStatusBarTintEnabled(true); // 使用颜色资源 tintManager.setStatusBarTintResource(R.color.button_pressed);&#125; 上面代码的意思就是 首先将状态栏的设置为透明，不透明，下面你设置的颜色是没有效果的。 然后再激活状态栏的设置。 给状态栏设置颜色]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>状态栏</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>